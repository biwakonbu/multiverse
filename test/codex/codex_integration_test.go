// +build codex

package codex

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/biwakonbu/agent-runner/internal/core"
	"github.com/biwakonbu/agent-runner/internal/meta"
	"github.com/biwakonbu/agent-runner/internal/note"
	"github.com/biwakonbu/agent-runner/internal/worker"
	"github.com/biwakonbu/agent-runner/pkg/config"
)

// TestCodex_BasicFlow tests basic Codex integration
func TestCodex_BasicFlow(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping Codex integration tests in short mode")
	}

	// Create temporary repo directory for test
	tmpDir := t.TempDir()

	// Create task configuration
	cfg := &config.TaskConfig{
		Version: 1,
		Task: config.TaskDetails{
			ID:    "TASK-CODEX-BASIC",
			Title: "Basic Codex Test",
			Repo:  tmpDir,
			PRD: config.PRDDetails{
				Text: "Create a simple hello.txt file with the text 'Hello from Codex'",
			},
		},
		Runner: config.RunnerConfig{
			Meta: config.MetaConfig{
				Kind: "mock",
			},
			Worker: config.WorkerConfig{
				Kind:          "codex-cli",
				DockerImage:   "agent-runner-codex:latest",
				MaxRunTimeSec: 300,
			},
		},
	}

	// Create executor
	executor, err := worker.NewExecutor(cfg.Runner.Worker, tmpDir)
	if err != nil {
		t.Skipf("Codex environment not available: %v", err)
	}

	// Create mock meta client
	metaClient := meta.NewMockClient()

	// Create note writer
	noteWriter := note.NewWriter()

	// Create runner
	runner := &core.Runner{
		Config: cfg,
		Meta:   metaClient,
		Worker: executor,
		Note:   noteWriter,
	}

	// Run task
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	taskCtx, err := runner.Run(ctx)
	if err != nil {
		t.Fatalf("Run() error = %v", err)
	}

	// Verify task completed
	if taskCtx.State != core.StateComplete && taskCtx.State != core.StateFailed {
		t.Errorf("Task state = %v, want COMPLETE or FAILED", taskCtx.State)
	}

	// Verify task note was created
	noteFile := filepath.Join(tmpDir, ".agent-runner", fmt.Sprintf("task-%s.md", cfg.Task.ID))
	if _, err := os.Stat(noteFile); os.IsNotExist(err) {
		t.Errorf("Task note file not created at %s", noteFile)
	}
}

// TestCodex_TaskConfigLoading tests loading task configuration from YAML
func TestCodex_TaskConfigLoading(t *testing.T) {
	yamlContent := `
version: 1

task:
  id: "TASK-CODEX-LOAD"
  title: "Load Test"
  repo: "/tmp/test"
  prd:
    text: "Test PRD"

runner:
  meta:
    kind: "mock"
  worker:
    kind: "codex-cli"
    docker_image: "agent-runner-codex:latest"
`

	var cfg config.TaskConfig
	err := yaml.Unmarshal([]byte(yamlContent), &cfg)
	if err != nil {
		t.Fatalf("yaml.Unmarshal() error = %v", err)
	}

	if cfg.Version != 1 {
		t.Errorf("Version = %d, want 1", cfg.Version)
	}
	if cfg.Task.ID != "TASK-CODEX-LOAD" {
		t.Errorf("Task.ID = %s, want 'TASK-CODEX-LOAD'", cfg.Task.ID)
	}
	if cfg.Runner.Worker.Kind != "codex-cli" {
		t.Errorf("Worker.Kind = %s, want 'codex-cli'", cfg.Runner.Worker.Kind)
	}
}

// TestCodex_FileGeneration tests that files generated by Codex are persisted
func TestCodex_FileGeneration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping Codex integration tests in short mode")
	}

	tmpDir := t.TempDir()

	cfg := &config.TaskConfig{
		Version: 1,
		Task: config.TaskDetails{
			ID:    "TASK-CODEX-FILE-GEN",
			Title: "File Generation Test",
			Repo:  tmpDir,
			PRD: config.PRDDetails{
				Text: "Create a file named 'generated.txt' with the content 'Generated by Codex'",
			},
		},
		Runner: config.RunnerConfig{
			Meta: config.MetaConfig{
				Kind: "mock",
			},
			Worker: config.WorkerConfig{
				Kind:          "codex-cli",
				DockerImage:   "agent-runner-codex:latest",
				MaxRunTimeSec: 300,
			},
		},
	}

	executor, err := worker.NewExecutor(cfg.Runner.Worker, tmpDir)
	if err != nil {
		t.Skipf("Codex environment not available: %v", err)
	}

	metaClient := meta.NewMockClient()
	noteWriter := note.NewWriter()

	runner := &core.Runner{
		Config: cfg,
		Meta:   metaClient,
		Worker: executor,
		Note:   noteWriter,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	taskCtx, err := runner.Run(ctx)
	if err != nil {
		t.Fatalf("Run() error = %v", err)
	}

	// Check that a markdown task note was created
	noteFile := filepath.Join(tmpDir, ".agent-runner", fmt.Sprintf("task-%s.md", cfg.Task.ID))
	if _, err := os.Stat(noteFile); os.IsNotExist(err) {
		t.Errorf("Task note file not created")
	}

	if taskCtx.State != core.StateComplete && taskCtx.State != core.StateFailed {
		t.Logf("Task completed with state: %v", taskCtx.State)
	}
}

// TestCodex_ErrorHandling tests error handling during Codex execution
func TestCodex_ErrorHandling(t *testing.T) {
	tmpDir := t.TempDir()

	cfg := &config.TaskConfig{
		Version: 1,
		Task: config.TaskDetails{
			ID:    "TASK-CODEX-ERROR",
			Title: "Error Handling Test",
			Repo:  tmpDir,
			PRD: config.PRDDetails{
				Text: "This is a minimal PRD for error testing",
			},
		},
		Runner: config.RunnerConfig{
			Meta: config.MetaConfig{
				Kind: "mock",
			},
			Worker: config.WorkerConfig{
				Kind:          "codex-cli",
				DockerImage:   "agent-runner-codex:latest",
				MaxRunTimeSec: 300,
			},
		},
	}

	executor, err := worker.NewExecutor(cfg.Runner.Worker, tmpDir)
	if err != nil {
		t.Skipf("Codex environment not available: %v", err)
	}

	metaClient := meta.NewMockClient()
	noteWriter := note.NewWriter()

	runner := &core.Runner{
		Config: cfg,
		Meta:   metaClient,
		Worker: executor,
		Note:   noteWriter,
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Task should complete without panic
	taskCtx, _ := runner.Run(ctx)

	if taskCtx.State != core.StateComplete && taskCtx.State != core.StateFailed {
		t.Errorf("Task state = %v, want COMPLETE or FAILED", taskCtx.State)
	}
}

// TestCodex_MockMode tests integration with mock Codex meta client
func TestCodex_MockMode(t *testing.T) {
	tmpDir := t.TempDir()

	cfg := &config.TaskConfig{
		Version: 1,
		Task: config.TaskDetails{
			ID:    "TASK-CODEX-MOCK",
			Title: "Mock Mode Test",
			Repo:  tmpDir,
			PRD: config.PRDDetails{
				Text: "Create a test file",
			},
		},
		Runner: config.RunnerConfig{
			Meta: config.MetaConfig{
				Kind: "mock",
			},
			Worker: config.WorkerConfig{
				Kind:          "codex-cli",
				DockerImage:   "agent-runner-codex:latest",
				MaxRunTimeSec: 300,
			},
		},
	}

	executor, err := worker.NewExecutor(cfg.Runner.Worker, tmpDir)
	if err != nil {
		t.Skipf("Codex environment not available: %v", err)
	}

	// Use mock meta client - this doesn't require actual LLM calls
	mockClient := meta.NewMockClient()

	noteWriter := note.NewWriter()

	runner := &core.Runner{
		Config: cfg,
		Meta:   mockClient,
		Worker: executor,
		Note:   noteWriter,
	}

	// Mock client should complete the flow without actual LLM
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	taskCtx, err := runner.Run(ctx)
	if err != nil {
		t.Logf("Run() error = %v (expected in mock mode)", err)
	}

	// Verify task note was created
	noteFile := filepath.Join(tmpDir, ".agent-runner", fmt.Sprintf("task-%s.md", cfg.Task.ID))
	if _, err := os.Stat(noteFile); os.IsNotExist(err) {
		t.Logf("Task note file not created (expected in quick mock run)")
	}

	t.Logf("Mock Codex integration completed with state: %v", taskCtx.State)
}

// TestCodex_TaskNoteGeneration tests that task notes are correctly generated
func TestCodex_TaskNoteGeneration(t *testing.T) {
	tmpDir := t.TempDir()

	taskCtx := &core.TaskContext{
		ID:       "TASK-CODEX-NOTE",
		Title:    "Note Generation Test",
		RepoPath: tmpDir,
		State:    core.StateComplete,
		PRDText:  "Sample PRD for note generation",
		AcceptanceCriteria: []core.AcceptanceCriterion{
			{
				ID:          "AC-1",
				Description: "Test criterion",
				Passed:      true,
			},
		},
		StartedAt:  time.Now(),
		FinishedAt: time.Now().Add(5 * time.Second),
	}

	writer := note.NewWriter()
	err := writer.Write(taskCtx)
	if err != nil {
		t.Fatalf("Write() error = %v", err)
	}

	// Verify note file was created
	noteFile := filepath.Join(tmpDir, ".agent-runner", fmt.Sprintf("task-%s.md", taskCtx.ID))
	if _, err := os.Stat(noteFile); os.IsNotExist(err) {
		t.Errorf("Task note file not created at %s", noteFile)
	}

	// Verify note content
	content, err := os.ReadFile(noteFile)
	if err != nil {
		t.Fatalf("Failed to read note file: %v", err)
	}

	contentStr := string(content)
	if !contains(contentStr, "TASK-CODEX-NOTE") {
		t.Errorf("Note file does not contain task ID")
	}
	if !contains(contentStr, "Note Generation Test") {
		t.Errorf("Note file does not contain task title")
	}
}

// TestCodex_EnvironmentIntegration tests environment variable integration
func TestCodex_EnvironmentIntegration(t *testing.T) {
	tmpDir := t.TempDir()

	cfg := &config.TaskConfig{
		Version: 1,
		Task: config.TaskDetails{
			ID:    "TASK-CODEX-ENV",
			Title: "Environment Test",
			Repo:  tmpDir,
			PRD: config.PRDDetails{
				Text: "Test environment variable propagation",
			},
		},
		Runner: config.RunnerConfig{
			Meta: config.MetaConfig{
				Kind: "mock",
			},
			Worker: config.WorkerConfig{
				Kind:          "codex-cli",
				DockerImage:   "agent-runner-codex:latest",
				MaxRunTimeSec: 300,
				Env: map[string]string{
					"TEST_ENV_VAR": "test_value",
				},
			},
		},
	}

	// Verify environment variables are in config
	if cfg.Runner.Worker.Env["TEST_ENV_VAR"] != "test_value" {
		t.Errorf("Environment variable not set in config")
	}
}

// Helper function to check if string contains substring
func contains(s, substr string) bool {
	for i := 0; i < len(s)-len(substr)+1; i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
